# coding: utf-8
# Code generated by vstruct. DO NOT EDIT.
# Package Name: main

from enum import Enum, unique

@unique
class Speices(Enum):
    human = 0
    elf = 1
    orc = 2
    dwarf = 3
    gnome = 4
    halfling = 5
    halfElf = 6
    halfOrc = 7
    dragonborn = 8
    tiefling = 9
    gnoll = 10
    goblin = 11

@unique
class ItemType(Enum):
    weapon = 0
    armor = 1
    potion = 2

class Coordinate():
    def __init__(self, x: I64, y: I64) {
        vSize = 16
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, x, y)


    def __len__(self):
        return len(self.vData)

    def toBytes(self):
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray):
        self = Coordinate.__new__()
        self.vData = b
        return self

  Uint8List vSerialize(Uint8List dst, I64 x, I64 y) {
    Uint8List __tmp_0 = x.toBytes();
    for (int i = 0; i < 8; i++) {
      dst[0 + i] = __tmp_0[i];
    }

    Uint8List __tmp_1 = y.toBytes();
    for (int i = 0; i < 8; i++) {
      dst[8 + i] = __tmp_1[i];
    }

    return dst;
  }

  I64 get x {
    I64 _value = I64.fromBytes(vData.sublist(0, 8));
    return _value;
  }

  I64 get y {
    I64 _value = I64.fromBytes(vData.sublist(8, 16));
    return _value;
  }

  bool vStructValidate() {
    return vData.lengthInBytes >= 16;
  }

}

class Item():
    def __init__(self, type: ItemType, damage: I64, armor: I64, name: String) {
        vSize = 25 + len(name)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, type, damage, armor, name)


    def __len__(self):
        return len(self.vData)

    def toBytes(self):
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray):
        self = Item.__new__()
        self.vData = b
        return self

  Uint8List vSerialize(Uint8List dst, ItemType type, I64 damage, I64 armor, String name) {
    dst[0] = type.index;

    Uint8List __tmp_1 = damage.toBytes();
    for (int i = 0; i < 8; i++) {
      dst[1 + i] = __tmp_1[i];
    }

    Uint8List __tmp_2 = armor.toBytes();
    for (int i = 0; i < 8; i++) {
      dst[9 + i] = __tmp_2[i];
    }

    U64 __index = U64(25);
    Uint8List __tmp_3 = (U64(name.length) + __index).toBytes();
    for (int i = 0; i < 8; i++) {
      dst[17 + i] = __tmp_3[i];
    }
    List<int> __tmp_4 = utf8.encode(name);
    Uint8List __tmp_5 = Uint8List.fromList(__tmp_4);
    for (int i = 0; i < name.length; i++) {
      dst[(__index + U64(i)).value.toInt()] = __tmp_5[i];
    }
    return dst;
  }

  ItemType get type {
    return ItemType.values[vData[0]];
  }

  I64 get damage {
    I64 _value = I64.fromBytes(vData.sublist(1, 9));
    return _value;
  }

  I64 get armor {
    I64 _value = I64.fromBytes(vData.sublist(9, 17));
    return _value;
  }

  String get name {
    U64 __off0 = U64(25);
    U64 __off1 = U64.fromBytes(vData.sublist(17, 25));

    return utf8.decode(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));
  }

  bool vStructValidate() {
    if (vData.lengthInBytes < 25) {
      return false;
    }

    U64 __off0 = U64(25);
    U64 __off1 = U64.fromBytes(vData.sublist(17, 25));
    U64 __off2 = U64(vData.lengthInBytes);
    return __off0 <= __off1 && __off1 <= __off2 ;
  }

}

class Inventory():
    def __init__(self, rightHand: Item, leftHand: Item) {
        vSize = 16 + len(rightHand) + len(leftHand)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, rightHand, leftHand)


    def __len__(self):
        return len(self.vData)

    def toBytes(self):
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray):
        self = Inventory.__new__()
        self.vData = b
        return self

  Uint8List vSerialize(Uint8List dst, Item rightHand, Item leftHand) {
    U64 __index = U64(16);
    Uint8List __tmp_0 = (U64(rightHand.lengthInBytes) + __index).toBytes();
    for (int i = 0; i < 8; i++) {
      dst[0 + i] = __tmp_0[i];
    }
    Uint8List __tmp_1 = rightHand.toBytes();
    for (int i = 0; i < rightHand.lengthInBytes; i++) {
      dst[(__index + U64(i)).value.toInt()] = __tmp_1[i];
    }
    __index = __index + U64(rightHand.lengthInBytes);
    Uint8List __tmp_2 = (U64(leftHand.lengthInBytes) + __index).toBytes();
    for (int i = 0; i < 8; i++) {
      dst[8 + i] = __tmp_2[i];
    }
    Uint8List __tmp_3 = leftHand.toBytes();
    for (int i = 0; i < leftHand.lengthInBytes; i++) {
      dst[(__index + U64(i)).value.toInt()] = __tmp_3[i];
    }
    return dst;
  }

  Item get rightHand {
    U64 __off0 = U64(16);
    U64 __off1 = U64.fromBytes(vData.sublist(0, 8));

    return Item.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));
  }

  Item get leftHand {
    U64 __off0 = U64.fromBytes(vData.sublist(0, 8));
    U64 __off1 = U64.fromBytes(vData.sublist(8, 16));

    return Item.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));
  }

  bool vStructValidate() {
    if (vData.lengthInBytes < 16) {
      return false;
    }

    U64 __off0 = U64(16);
    U64 __off1 = U64.fromBytes(vData.sublist(0, 8));
    U64 __off2 = U64.fromBytes(vData.sublist(8, 16));
    U64 __off3 = U64(vData.lengthInBytes);
    if (__off0 <= __off1 && __off1 <= __off2 && __off2 <= __off3 ) {
      return rightHand.vStructValidate() && leftHand.vStructValidate();
    }

    return false;
  }

}

class Entity():
    def __init__(self, type: Speices, position: Coordinate, hp: I64, id: UUID, inventory: Inventory) {
        vSize = 41 + len(id) + len(inventory)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, type, position, hp, id, inventory)


    def __len__(self):
        return len(self.vData)

    def toBytes(self):
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray):
        self = Entity.__new__()
        self.vData = b
        return self

  Uint8List vSerialize(Uint8List dst, Speices type, Coordinate position, I64 hp, UUID id, Inventory inventory) {
    dst[0] = type.index;

    Uint8List __tmp_1 = position.toBytes();
    for (int i = 0; i < position.lengthInBytes; i++) {
      dst[1 + i] = __tmp_1[i];
    }

    Uint8List __tmp_2 = hp.toBytes();
    for (int i = 0; i < 8; i++) {
      dst[17 + i] = __tmp_2[i];
    }

    U64 __index = U64(41);
    Uint8List __tmp_3 = (U64(id.length) + __index).toBytes();
    for (int i = 0; i < 8; i++) {
      dst[25 + i] = __tmp_3[i];
    }
    List<int> __tmp_4 = utf8.encode(id);
    Uint8List __tmp_5 = Uint8List.fromList(__tmp_4);
    for (int i = 0; i < id.length; i++) {
      dst[(__index + U64(i)).value.toInt()] = __tmp_5[i];
    }
    __index = __index + U64(id.length);
    Uint8List __tmp_6 = (U64(inventory.lengthInBytes) + __index).toBytes();
    for (int i = 0; i < 8; i++) {
      dst[33 + i] = __tmp_6[i];
    }
    Uint8List __tmp_7 = inventory.toBytes();
    for (int i = 0; i < inventory.lengthInBytes; i++) {
      dst[(__index + U64(i)).value.toInt()] = __tmp_7[i];
    }
    return dst;
  }

  Speices get type {
    return Speices.values[vData[0]];
  }

  Coordinate get position {
    return Coordinate.fromBytes(vData.sublist(1, 17));
  }

  I64 get hp {
    I64 _value = I64.fromBytes(vData.sublist(17, 25));
    return _value;
  }

  UUID get id {
    U64 __off0 = U64(41);
    U64 __off1 = U64.fromBytes(vData.sublist(25, 33));

    return utf8.decode(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));
  }

  Inventory get inventory {
    U64 __off0 = U64.fromBytes(vData.sublist(25, 33));
    U64 __off1 = U64.fromBytes(vData.sublist(33, 41));

    return Inventory.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));
  }

  bool vStructValidate() {
    if (vData.lengthInBytes < 41) {
      return false;
    }

    U64 __off0 = U64(41);
    U64 __off1 = U64.fromBytes(vData.sublist(25, 33));
    U64 __off2 = U64.fromBytes(vData.sublist(33, 41));
    U64 __off3 = U64(vData.lengthInBytes);
    if (__off0 <= __off1 && __off1 <= __off2 && __off2 <= __off3 ) {
      return inventory.vStructValidate();
    }

    return false;
  }

}

typedef UUID = String;

