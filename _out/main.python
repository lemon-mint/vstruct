# coding: utf-8
# Code generated by vstruct. DO NOT EDIT.
# Package Name: main

from enum import Enum, unique
from typing import TypeAlias
import struct

UUID: TypeAlias = str

@unique
class Speices(Enum):
    human = 0
    elf = 1
    orc = 2
    dwarf = 3
    gnome = 4
    halfling = 5
    halfElf = 6
    halfOrc = 7
    dragonborn = 8
    tiefling = 9
    gnoll = 10
    goblin = 11

@unique
class ItemType(Enum):
    weapon = 0
    armor = 1
    potion = 2

class Coordinate():
    def __init__(self, x: int, y: int) {
        vSize = 16
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, x, y)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> Coordinate:
        self = Coordinate.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, x: int, y: int) -> bytearray:
        __tmp_0 = x.to_bytes(8, 'little')
        dst[0:8] = __tmp_0

        __tmp_1 = y.to_bytes(8, 'little')
        dst[8:16] = __tmp_1

    	return dst

    @property
    def x(self) -> int:
    	return int.from_bytes(s[0:8], byteorder='little')

    @property
    def y(self) -> int:
    	return int.from_bytes(s[8:16], byteorder='little')

  bool vStructValidate() {
    return vData.lengthInBytes >= 16;
  }

}

class Item():
    def __init__(self, type: ItemType, damage: int, armor: int, name: str) {
        vSize = 25 + len(name)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, type, damage, armor, name)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> Item:
        self = Item.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, type: ItemType, damage: int, armor: int, name: str) -> bytearray:
        dst[0] = type.value

        __tmp_1 = damage.to_bytes(8, 'little')
        dst[1:9] = __tmp_1

        __tmp_2 = armor.to_bytes(8, 'little')
        dst[9:17] = __tmp_2

        __index = 25
    	__tmp_3 = (len(name) + __index).to_bytes(8, 'little')
    	dst[17:25] = __tmp_3
        __tmp_4 = name.encode('utf-8')
    	dst[__index:__index+len(__tmp_4)] = __tmp_4
    	return dst

    @property
    def type(self) -> ItemType:
    return ItemType(s[0])

    @property
    def damage(self) -> int:
    	return int.from_bytes(s[1:9], byteorder='little')

    @property
    def armor(self) -> int:
    	return int.from_bytes(s[9:17], byteorder='little')

  str get name {
    U64 __off0 = U64(25);
    U64 __off1 = U64.fromBytes(vData.sublist(17, 25));

    return utf8.decode(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));

  bool vStructValidate() {
    if (vData.lengthInBytes < 25) {
      return false;
    }

    U64 __off0 = U64(25);
    U64 __off1 = U64.fromBytes(vData.sublist(17, 25));
    U64 __off2 = U64(vData.lengthInBytes);
    return __off0 <= __off1 && __off1 <= __off2 ;
  }

}

class Inventory():
    def __init__(self, rightHand: Item, leftHand: Item) {
        vSize = 16 + len(rightHand) + len(leftHand)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, rightHand, leftHand)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> Inventory:
        self = Inventory.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, rightHand: Item, leftHand: Item) -> bytearray:
        __index = 16
    	__tmp_0 = (rightHand.__len__() + __index).to_bytes(8, 'little')
    	dst[0:8] = __tmp_0
    	__tmp_1 = rightHand.toBytes()
    	dst[__index:__index+len(__tmp_1)] = __tmp_1
    	__index = __index + rightHand.__len__()
    	__tmp_2 = (leftHand.__len__() + __index).to_bytes(8, 'little')
    	dst[8:16] = __tmp_2
    	__tmp_3 = leftHand.toBytes()
    	dst[__index:__index+len(__tmp_3)] = __tmp_3
    	return dst

  Item get rightHand {
    U64 __off0 = U64(16);
    U64 __off1 = U64.fromBytes(vData.sublist(0, 8));

    return Item.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));

  Item get leftHand {
    U64 __off0 = U64.fromBytes(vData.sublist(0, 8));
    U64 __off1 = U64.fromBytes(vData.sublist(8, 16));

    return Item.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));

  bool vStructValidate() {
    if (vData.lengthInBytes < 16) {
      return false;
    }

    U64 __off0 = U64(16);
    U64 __off1 = U64.fromBytes(vData.sublist(0, 8));
    U64 __off2 = U64.fromBytes(vData.sublist(8, 16));
    U64 __off3 = U64(vData.lengthInBytes);
    if (__off0 <= __off1 && __off1 <= __off2 && __off2 <= __off3 ) {
      return rightHand.vStructValidate() && leftHand.vStructValidate();
    }

    return false;
  }

}

class Entity():
    def __init__(self, type: Speices, position: Coordinate, hp: int, id: UUID, inventory: Inventory) {
        vSize = 41 + len(id) + len(inventory)
        vData = bytearray(vSize)
        vData = self.vSerialize(self.vData, type, position, hp, id, inventory)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> Entity:
        self = Entity.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, type: Speices, position: Coordinate, hp: int, id: UUID, inventory: Inventory) -> bytearray:
        dst[0] = type.value

        __tmp_1 = position.toBytes()
        dst[1:1+len(__tmp_1)] = __tmp_1

        __tmp_2 = hp.to_bytes(8, 'little')
        dst[17:25] = __tmp_2

        __index = 41
    	__tmp_3 = (len(id) + __index).to_bytes(8, 'little')
    	dst[25:33] = __tmp_3
        __tmp_4 = id.encode('utf-8')
    	dst[__index:__index+len(__tmp_4)] = __tmp_4
    	__index = __index + len(id)
    	__tmp_5 = (inventory.__len__() + __index).to_bytes(8, 'little')
    	dst[33:41] = __tmp_5
    	__tmp_6 = inventory.toBytes()
    	dst[__index:__index+len(__tmp_6)] = __tmp_6
    	return dst

    @property
    def type(self) -> Speices:
    return Speices(s[0])

    @property
    def position(self) -> Coordinate:
    	return Coordinate.fromBytes(s[1:17])

    @property
    def hp(self) -> int:
    	return int.from_bytes(s[17:25], byteorder='little')

  UUID get id {
    U64 __off0 = U64(41);
    U64 __off1 = U64.fromBytes(vData.sublist(25, 33));

    return utf8.decode(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));

  Inventory get inventory {
    U64 __off0 = U64.fromBytes(vData.sublist(25, 33));
    U64 __off1 = U64.fromBytes(vData.sublist(33, 41));

    return Inventory.fromBytes(vData.sublist(__off0.value.toInt(), __off1.value.toInt()));

  bool vStructValidate() {
    if (vData.lengthInBytes < 41) {
      return false;
    }

    U64 __off0 = U64(41);
    U64 __off1 = U64.fromBytes(vData.sublist(25, 33));
    U64 __off2 = U64.fromBytes(vData.sublist(33, 41));
    U64 __off3 = U64(vData.lengthInBytes);
    if (__off0 <= __off1 && __off1 <= __off2 && __off2 <= __off3 ) {
      return inventory.vStructValidate();
    }

    return false;
  }

}


