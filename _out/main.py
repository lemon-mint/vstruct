# coding: utf-8
# Code generated by vstruct. DO NOT EDIT.
# Package Name: main

from enum import Enum, unique
from typing import TypeAlias
import struct

UUID: TypeAlias = str

@unique
class Speices(Enum):
    human = 0
    elf = 1
    orc = 2
    dwarf = 3
    gnome = 4
    halfling = 5
    halfElf = 6
    halfOrc = 7
    dragonborn = 8
    tiefling = 9
    gnoll = 10
    goblin = 11

@unique
class ItemType(Enum):
    weapon = 0
    armor = 1
    potion = 2

class Coordinate():
    def __init__(self, x: int, y: int):
        vSize = 16
        self.vData = bytearray(vSize)
        self.vData = self.vSerialize(self.vData, x, y)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> 'Coordinate':
        self = Coordinate.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, x: int, y: int) -> bytearray:
        __tmp_0 = x.to_bytes(8, 'little')
        dst[0:8] = __tmp_0

        __tmp_1 = y.to_bytes(8, 'little')
        dst[8:16] = __tmp_1

        return dst

    @property
    def x(self) -> int:
        return int.from_bytes(self.vData[0:8], byteorder='little')

    @property
    def y(self) -> int:
        return int.from_bytes(self.vData[8:16], byteorder='little')

    def vStructValidate(self) -> bool:
        return len(self.vData) >= 16


class Item():
    def __init__(self, type: ItemType, damage: int, armor: int, name: str):
        vSize = 25 + len(name)
        self.vData = bytearray(vSize)
        self.vData = self.vSerialize(self.vData, type, damage, armor, name)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> 'Item':
        self = Item.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, type: ItemType, damage: int, armor: int, name: str) -> bytearray:
        dst[0] = type.value

        __tmp_1 = damage.to_bytes(8, 'little')
        dst[1:9] = __tmp_1

        __tmp_2 = armor.to_bytes(8, 'little')
        dst[9:17] = __tmp_2

        __index = 25
        __tmp_3 = (len(name) + __index).to_bytes(8, 'little')
        dst[17:25] = __tmp_3
        __tmp_4 = name.encode('utf-8')
        dst[__index:__index+len(__tmp_4)] = __tmp_4
        return dst

    @property
    def type(self) -> ItemType:
        return ItemType(self.vData[0])

    @property
    def damage(self) -> int:
        return int.from_bytes(self.vData[1:9], byteorder='little')

    @property
    def armor(self) -> int:
        return int.from_bytes(self.vData[9:17], byteorder='little')

    @property
    def name(self) -> str:
        __off0 = 25
        __off1 = int.from_bytes(self.vData[17:25], byteorder='little')

        return self.vData[__off0:__off1].decode('utf-8')

    def vStructValidate(self) -> bool:
        if len(self.vData) < 25:
            return False

        __off0 = 25
        __off1 = int.from_bytes(self.vData[17:25], byteorder='little')
        __off2 = len(self.vData)

        return __off0 <= __off1 and __off1 <= __off2

class Inventory():
    def __init__(self, rightHand: Item, leftHand: Item):
        vSize = 16 + len(rightHand) + len(leftHand)
        self.vData = bytearray(vSize)
        self.vData = self.vSerialize(self.vData, rightHand, leftHand)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> 'Inventory':
        self = Inventory.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, rightHand: Item, leftHand: Item) -> bytearray:
        __index = 16
        __tmp_0 = (rightHand.__len__() + __index).to_bytes(8, 'little')
        dst[0:8] = __tmp_0
        __tmp_1 = rightHand.toBytes()
        dst[__index:__index+len(__tmp_1)] = __tmp_1
        __index = __index + rightHand.__len__()
        __tmp_2 = (leftHand.__len__() + __index).to_bytes(8, 'little')
        dst[8:16] = __tmp_2
        __tmp_3 = leftHand.toBytes()
        dst[__index:__index+len(__tmp_3)] = __tmp_3
        return dst

    @property
    def rightHand(self) -> Item:
        __off0 = 16
        __off1 = int.from_bytes(self.vData[0:8], byteorder='little')

        return Item.fromBytes(self.vData[__off0:__off1])

    @property
    def leftHand(self) -> Item:
        __off0 = int.from_bytes(self.vData[0:8], byteorder='little')
        __off1 = int.from_bytes(self.vData[8:16], byteorder='little')

        return Item.fromBytes(self.vData[__off0:__off1])

    def vStructValidate(self) -> bool:
        if len(self.vData) < 16:
            return False

        __off0 = 16
        __off1 = int.from_bytes(self.vData[0:8], byteorder='little')
        __off2 = int.from_bytes(self.vData[8:16], byteorder='little')
        __off3 = len(self.vData)

        if __off0 <= __off1 and __off1 <= __off2 and __off2 <= __off3:
            return self.rightHand.vStructValidate() and self.leftHand.vStructValidate()
        return False


class Entity():
    def __init__(self, type: Speices, position: Coordinate, hp: int, id: UUID, inventory: Inventory):
        vSize = 41 + len(id) + len(inventory)
        self.vData = bytearray(vSize)
        self.vData = self.vSerialize(self.vData, type, position, hp, id, inventory)


    def __len__(self) -> int:
        return len(self.vData)

    def toBytes(self) -> bytearray:
        return self.vData

    @staticmethod
    def fromBytes(b: bytearray) -> 'Entity':
        self = Entity.__new__()
        self.vData = b
        return self

    def vSerialize(self, dst: bytearray, type: Speices, position: Coordinate, hp: int, id: UUID, inventory: Inventory) -> bytearray:
        dst[0] = type.value

        __tmp_1 = position.toBytes()
        dst[1:1+len(__tmp_1)] = __tmp_1

        __tmp_2 = hp.to_bytes(8, 'little')
        dst[17:25] = __tmp_2

        __index = 41
        __tmp_3 = (len(id) + __index).to_bytes(8, 'little')
        dst[25:33] = __tmp_3
        __tmp_4 = id.encode('utf-8')
        dst[__index:__index+len(__tmp_4)] = __tmp_4
        __index = __index + len(id)
        __tmp_5 = (inventory.__len__() + __index).to_bytes(8, 'little')
        dst[33:41] = __tmp_5
        __tmp_6 = inventory.toBytes()
        dst[__index:__index+len(__tmp_6)] = __tmp_6
        return dst

    @property
    def type(self) -> Speices:
        return Speices(self.vData[0])

    @property
    def position(self) -> Coordinate:
        return Coordinate.fromBytes(self.vData[1:17])

    @property
    def hp(self) -> int:
        return int.from_bytes(self.vData[17:25], byteorder='little')

    @property
    def id(self) -> UUID:
        __off0 = 41
        __off1 = int.from_bytes(self.vData[25:33], byteorder='little')

        return self.vData[__off0:__off1].decode('utf-8')

    @property
    def inventory(self) -> Inventory:
        __off0 = int.from_bytes(self.vData[25:33], byteorder='little')
        __off1 = int.from_bytes(self.vData[33:41], byteorder='little')

        return Inventory.fromBytes(self.vData[__off0:__off1])

    def vStructValidate(self) -> bool:
        if len(self.vData) < 41:
            return False

        __off0 = 41
        __off1 = int.from_bytes(self.vData[25:33], byteorder='little')
        __off2 = int.from_bytes(self.vData[33:41], byteorder='little')
        __off3 = len(self.vData)

        if __off0 <= __off1 and __off1 <= __off2 and __off2 <= __off3:
            return self.inventory.vStructValidate()
        return False



