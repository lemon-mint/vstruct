#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(non_snake_case)]

// Code generated by vstruct. DO NOT EDIT.
// Package Name: main

enum Speices {
    Human,
    Elf,
    Orc,
    Dwarf,
    Gnome,
    Halfling,
    HalfElf,
    HalfOrc,
    Dragonborn,
    Tiefling,
    Gnoll,
    Goblin
}

enum ItemType {
    Weapon,
    Armor,
    Potion
}

struct Coordinate {
    buffer: Vec<u8>,
}

impl Coordinate {
    fn new(X: i64, Y: i64, ) -> Coordinate {
        let mut buffer = Vec::new();

        let __unsigned_X = X as u64;
        buffer.push(__unsigned_X as u8);
        buffer.push((__unsigned_X >> 8) as u8);
        buffer.push((__unsigned_X >> 16) as u8);
        buffer.push((__unsigned_X >> 24) as u8);
        buffer.push((__unsigned_X >> 32) as u8);
        buffer.push((__unsigned_X >> 40) as u8);
        buffer.push((__unsigned_X >> 48) as u8);
        buffer.push((__unsigned_X >> 56) as u8);

        let __unsigned_Y = Y as u64;
        buffer.push(__unsigned_Y as u8);
        buffer.push((__unsigned_Y >> 8) as u8);
        buffer.push((__unsigned_Y >> 16) as u8);
        buffer.push((__unsigned_Y >> 24) as u8);
        buffer.push((__unsigned_Y >> 32) as u8);
        buffer.push((__unsigned_Y >> 40) as u8);
        buffer.push((__unsigned_Y >> 48) as u8);
        buffer.push((__unsigned_Y >> 56) as u8);

        Coordinate { buffer: buffer }
    }

    fn as_bytes(&self) -> &[u8] {
        &self.buffer[..]
    }
}

struct Item {
    buffer: Vec<u8>,
}

impl Item {
    fn new(Type: ItemType, Damage: i64, Armor: i64, Name: &String) -> Item {
        let mut buffer = Vec::new();

        buffer.push(Type as u8);

        let __unsigned_Damage = Damage as u64;
        buffer.push(__unsigned_Damage as u8);
        buffer.push((__unsigned_Damage >> 8) as u8);
        buffer.push((__unsigned_Damage >> 16) as u8);
        buffer.push((__unsigned_Damage >> 24) as u8);
        buffer.push((__unsigned_Damage >> 32) as u8);
        buffer.push((__unsigned_Damage >> 40) as u8);
        buffer.push((__unsigned_Damage >> 48) as u8);
        buffer.push((__unsigned_Damage >> 56) as u8);

        let __unsigned_Armor = Armor as u64;
        buffer.push(__unsigned_Armor as u8);
        buffer.push((__unsigned_Armor >> 8) as u8);
        buffer.push((__unsigned_Armor >> 16) as u8);
        buffer.push((__unsigned_Armor >> 24) as u8);
        buffer.push((__unsigned_Armor >> 32) as u8);
        buffer.push((__unsigned_Armor >> 40) as u8);
        buffer.push((__unsigned_Armor >> 48) as u8);
        buffer.push((__unsigned_Armor >> 56) as u8);

        let __string_bytes_Name = Name.as_bytes();
        buffer.extend_from_slice(__string_bytes_Name);

        Item { buffer: buffer }
    }

    fn as_bytes(&self) -> &[u8] {
        &self.buffer[..]
    }
}

struct Inventory {
    buffer: Vec<u8>,
}

impl Inventory {
    fn new(RightHand: &Item, LeftHand: &Item) -> Inventory {
        let mut buffer = Vec::new();

        let __struct_bytes_RightHand = RightHand.as_bytes();
        buffer.extend_from_slice(__struct_bytes_RightHand);

        let __struct_bytes_LeftHand = LeftHand.as_bytes();
        buffer.extend_from_slice(__struct_bytes_LeftHand);

        Inventory { buffer: buffer }
    }

    fn as_bytes(&self) -> &[u8] {
        &self.buffer[..]
    }
}

struct Entity {
    buffer: Vec<u8>,
}

impl Entity {
    fn new(Type: Speices, Position: &Coordinate, Hp: i64, Id: &UUID, Inventory: &Inventory) -> Entity {
        let mut buffer = Vec::new();

        buffer.push(Type as u8);

        let __struct_bytes_Position = Position.as_bytes();
        buffer.extend_from_slice(__struct_bytes_Position);

        let __unsigned_Hp = Hp as u64;
        buffer.push(__unsigned_Hp as u8);
        buffer.push((__unsigned_Hp >> 8) as u8);
        buffer.push((__unsigned_Hp >> 16) as u8);
        buffer.push((__unsigned_Hp >> 24) as u8);
        buffer.push((__unsigned_Hp >> 32) as u8);
        buffer.push((__unsigned_Hp >> 40) as u8);
        buffer.push((__unsigned_Hp >> 48) as u8);
        buffer.push((__unsigned_Hp >> 56) as u8);

        let __string_bytes_Id = Id.as_bytes();
        buffer.extend_from_slice(__string_bytes_Id);

        let __struct_bytes_Inventory = Inventory.as_bytes();
        buffer.extend_from_slice(__struct_bytes_Inventory);

        Entity { buffer: buffer }
    }

    fn as_bytes(&self) -> &[u8] {
        &self.buffer[..]
    }
}

type UUID = String;

fn main() {
    let e = Entity::new(
        Speices::Human,
        &Coordinate::new(0, 0, ),
        0,
        &UUID::from("0".to_string(), ),
        &Inventory::new(
            &Item::new(
                ItemType::Weapon,
                0,
                0,
                &String::from("0".to_string(), ),
            ),
            &Item::new(
                ItemType::Armor,
                0,
                0,
                &String::from("0".to_string(), ),
            ),
        ),
    );
}
